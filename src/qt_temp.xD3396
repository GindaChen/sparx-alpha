#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>

#include <gsl/gsl_interp.h>

#include "memory.h"
#include "zone.h"
#include "debug.h"

/*----------------------------------------------------------------------------*/

Zone *_Zone_Alloc(size_t pos, Zone *parent, void *(*DataAlloc)(const Zone *, const void *), const void *data_parms)
{
	Zone *zp = Mem_CALLOC(1, zp);

	/* level is parent's + 1, and -1 for root */
	if(!parent) {
		/* This is the root zone, level = -1 */
		zp->level = -1;

		/* Root zone is of course this zone */
		zp->root = zp;
	}
	else {
		/* Level of this zone is parent level + 1 */
		zp->level = parent->level + 1;

		/* Inherit root zone pointer from parent */
		zp->root = parent->root;
	}

	/* pos is relative to the parent->children array */
	zp->pos = pos;

	/* Parent node */
	zp->parent = parent;

	/* Allocate data if constructor is specified */
	if(DataAlloc)
		zp->data = DataAlloc(zp, data_parms);


	return zp;
}

/*----------------------------------------------------------------------------*/

void Zone_Free(void *ptr, void (*DataFree)(void *ptr))
{
	size_t i;
	Zone *zone = ptr;

	if(DataFree) {
		Deb_ASSERT(zone->data != NULL);

		/* Free data */
		DataFree(zone->data);
	}

	if(zone->children) {
		/* Free children */
		for(i = 0; i < zone->nchildren; i++) {
			Zone_Free(zone->children[i], DataFree);
		}

		/* Free pointer to cildren */
		free(zone->children);
	}

	free(zone);
}

/*----------------------------------------------------------------------------*/

void Zone_Fprintf(FILE *fp, const Zone *zone, void (*DataFprintf)(void *data, FILE *fp))
{
	size_t nindent = (size_t)(4 * (zone->level + 1));
	size_t i;
	DatINode *geom;

	#define PINDENT\
		{for(i = 0; i < nindent; i++) fprintf(fp, " ");}

	if(!zone->parent) {
		fprintf(fp, "== ROOT Zone ==\n");
	}
	else {
		PINDENT; fprintf(fp, "Zone[%lu] ", (unsigned long)zone->pos);
		GeVec3_PRINT(fp, zone->index);
		fprintf(fp, "\n");
	}
	geom = Dat_IList_IdxLookup(GEOM_TYPES, zone->voxel.geom);
	Deb_ASSERT(geom != NULL);
	PINDENT; fprintf(fp, "Geometry: "); fprintf(fp, "%s\n", geom->name);
	PINDENT; fprintf(fp, "Min: "); GeVec3_PRINT(fp, zone->voxel.min); fprintf(fp, "\n");
	PINDENT; fprintf(fp, "Cen: "); GeVec3_PRINT(fp, zone->voxel.cen); fprintf(fp, "\n");
	PINDENT; fprintf(fp, "Max: "); GeVec3_PRINT(fp, zone->voxel.max); fprintf(fp, "\n");

	if(DataFprintf) {
		PINDENT; fprintf(fp, "Data: ");
		DataFprintf(zone->data, fp);
	}

	fprintf(fp, "\n");

	if(zone->children) {
		PINDENT;
		fprintf(fp, "=== L%d Grid ", zone->level + 1);
		GeVec3_PRINT(fp, zone->naxes);
		fprintf(fp, "===\n");

		for(i = 0; i < zone->nchildren; i++)
			Zone_Fprintf(fp, zone->children[i], DataFprintf);
	}

	#undef PINDENT

	return;
}

/*----------------------------------------------------------------------------*/

void Zone_GrowChildren(Zone *zone, GeVec3_s naxes, void *(*DataAlloc)(const Zone *, const void *), const void *data_parms)
/* Grow 'children' from the current zone according
   to the number of divisions specified */
{
	size_t i;

	/* Calculate total number of children */
	zone->nchildren = naxes.x[0] * naxes.x[1] * naxes.x[2];
	Deb_ASSERT(zone->nchildren >= 1);
	zone->naxes = naxes;

	/* Allocate array of pointers for children */
	zone->children = Mem_CALLOC(zone->nchildren, zone->children);

	/* Loop through pointers and allocate each child */
	for(i = 0; i < zone->nchildren; i++) {
		/* Allocate sub-zone */
		zone->children[i] = Zone_Alloc(i, zone, DataAlloc, data_parms);

		/* Set sub-zone index */
		zone->children[i]->index = Ge_IelemToIndex(i, &naxes);

		/* Set sub-zone voxel */
		Zone_Set_child_voxel(zone, i);
	}

	return;
}

/*----------------------------------------------------------------------------*/

void Zone_Set_child_voxel(Zone *zone, size_t pos)
/* Calculated voxel according to parent zone */
{
	Zone *child = zone->children[pos];

	child->voxel = GeVox_GetSubVox(&zone->voxel, &child->index, &zone->naxes);

	return;
}

/*----------------------------------------------------------------------------*/

Zone *Zone_GetMinLeaf(Zone *zone)
{
	if(zone->children)
		return Zone_GetMinLeaf(zone->children[0]);
	else
		return zone;
}

/*----------------------------------------------------------------------------*/

Zone *Zone_GetMaxLeaf(Zone *zone)
{
	if(zone->children)
		return Zone_GetMaxLeaf(zone->children[zone->nchildren - 1]);
	else
		return zone;
}

/*----------------------------------------------------------------------------*/

Zone *Zone_GetInner(Zone *zone)
{
	Zone *parent = zone->parent;

	if(parent) {
		if(zone->pos > 0) {
			return Zone_GetMaxLeaf(parent->children[zone->pos - 1]);
		}
		else if(parent->parent) {
			return Zone_GetInner(parent);
		}
	}

	return NULL;
}

/*----------------------------------------------------------------------------*/

Zone *Zone_GetOuter(Zone *zone)
{
	Zone *parent = zone->parent;

	if(parent) {
		if(zone->pos < parent->nchildren - 1) {
			return Zone_GetMinLeaf(parent->children[zone->pos + 1]);
		}
		else if(parent->parent) {
			return Zone_GetOuter(parent);
		}
	}

	return NULL;
}

/*----------------------------------------------------------------------------*/

Zone *Zone_AscendTree(Zone *zone)
{
	Zone *parent = zone->parent;

	if(parent) {
		if(zone->pos < parent->nchildren - 1)
			return Zone_GetMinLeaf(parent->children[zone->pos + 1]);
		else
			return parent;
	}

	return NULL;
}

/*----------------------------------------------------------------------------*/

Zone *Zone_GetLeaf(Zone *zone, size_t side, const GeVec3_d *pt, GeRay *ray)
{
	Zone *leaf = NULL;

	switch(zone->voxel.geom) {
		case GEOM_SPH1D:
			leaf = Zone_GetLeaf_sph1d(zone, side);
			break;

		case GEOM_SPH3D:
			leaf = Zone_GetLeaf_sph3d(zone, side, pt, ray);
			break;
		
		case GEOM_REC3D:
			leaf = Zone_GetLeaf_rec3d(zone, side, pt);
			break;

		default: /* Shouldn't happen */
			Deb_ASSERT(0);
	}

	return leaf;
}

/*----------------------------------------------------------------------------*/

Zone *Zone_GetLeaf_sph1d(Zone *zone, size_t side)
/* Locate leaf zone nearest to side */
{
	Zone *leaf = 0;

	if(side == 0) { /* Entering from inner sphere */
		leaf = Zone_GetMinLeaf(zone);
	}
	else if(side == 1) { /* Entering from outer sphere */
		leaf = Zone_GetMaxLeaf(zone);
	}
	else { /* Shouldn't happen */
		Deb_ASSERT(0);
	}

	return leaf;
}

/*----------------------------------------------------------------------------*/
Zone *Zone_GetLeaf_sph3d(Zone *zone, size_t side, const GeVec3_d *pt, GeRay *ray)
/* Locate leaf zone on side containing pt */
{
	size_t i, j;
	GeVec3_s idx = GeVec3_INIT(0, 0, 0), pos = GeVec3_INIT(0, 0, 0);
	size_t axis = side / 2, n;
	Zone *child = 0;
	double *array;
	double R,Rc;
	double pi=3.1415926535897932384626433832795;

	/* If zone does not have children, zone is the leaf */
	if(!zone->children)
		return zone;

	/* Otherwise search for child containing pt */
	for(i = 0; i < 3; i++) {
		n = GeVec3_X(zone->naxes, i);

		if(i == axis) {
			/* We already know the position on the driving axis -- this saves
			 * some time */
			GeVec3_X(pos, i) = (side % 2 == 0) ? 0 : n - 1;
		}
		else {
			/* Allocate array for binary search and load coordinate boundaries */
			array = Mem_CALLOC(n + 1, array);

			/* The Oth element should contain the lower bound */
			child = Zone_CHILD(zone, idx);
			array[0] = GeVec3_X(child->voxel.min, i);

			/* All other elements are upper bounds */
			for(j = 0; j < n; j++) {
				GeVec3_X(idx, i) = j;
				child = Zone_CHILD(zone, idx);
				array[j + 1] = GeVec3_X(child->voxel.max, i);
			}

			/* Do a binary search -- there MUST always be a match */
			if(i==0) // Radius search
				GeVec3_X(pos, i) = 
					gsl_interp_bsearch(array, GeVec3_X(*pt, i), (size_t)0, n);
			else if(i==1){ // Theta search
				R=sqrt(pt->x[0] * pt->x[0] + pt->x[1] * pt->x[1] + pt->x[2] * pt->x[2]);
				GeVec3_X(pos, i) = 
					gsl_interp_bsearch(array,
							   (R>=1e-8)?
								acos( pt->x[2] / R):
								acos(GeRay_D(*ray,2))	
							, (size_t)0, n);
			}
			else if(i==2){ // Phi search
				Rc=sqrt(pt->x[0] * pt->x[0] + pt->x[1] * pt->x[1]);	
				GeVec3_X(pos, i) = 
					gsl_interp_bsearch(array, 
							