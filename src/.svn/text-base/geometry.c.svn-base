#include <stdio.h>
#include <math.h>
#include <assert.h>
#include <float.h>
#include <gsl/gsl_rng.h>

#include "memory.h"
#include "debug.h"
#include "cpgplot-wrappers.h"
#include "numerical.h"
#include "geometry.h"

DatINode GEOM_TYPES[] = {
	{"sph1d", GEOM_SPH1D},
	{"rec3d", GEOM_REC3D},
	{0, 0}
};

DatINode *GEOM_TYPESP = GEOM_TYPES;

static void GeVox_Cpgplot_sph1d(const GeVox *voxel);
static void GeVox_Cpgplot_rec(const GeVox *voxel, const GeCam *cam);

/*----------------------------------------------------------------------------*/

size_t Ge_PosToIelem(size_t i, size_t j, size_t k, const GeVec3_s *naxes)
{
 	size_t ielem = 0;

	ielem = (k) + GeVec3_X(*naxes, 2) * ((j) + GeVec3_X(*naxes, 1) * (i));

	return ielem;
}

/*----------------------------------------------------------------------------*/

GeVec3_s Ge_IelemToIndex(size_t ielem, const GeVec3_s *naxes)
{
	size_t i;
	GeVec3_s idx;

	for(i = 0; i < 3; i++) {
		GeVec3_X(idx, 2 - i) = ielem % GeVec3_X(*naxes, 2 - i);
		ielem = ielem / GeVec3_X(*naxes, 2 - i);
	}

	return idx;
}

/*----------------------------------------------------------------------------*/

size_t Ge_IndexToIelem(const GeVec3_s *idx, const GeVec3_s *naxes)
{
	size_t i, ielem = 0;

	for(i = 0; i < 3; i++) {
		ielem = i == 0 ? GeVec3_X(*idx, i) : ielem * GeVec3_X(*naxes, i) + GeVec3_X(*idx, i);
	}

	return ielem;
}

/*----------------------------------------------------------------------------*/

GeVox GeVox_GetSubVox(const GeVox *voxel, const GeVec3_s *idx, const GeVec3_s *naxes)
{
	size_t i;
	double delta;
	GeVox subvox;

	for(i = 0; i < 3; i++) {
		/* Remember to update these if the GeVox struct changes!!! */
		subvox.geom = voxel->geom;
		delta = subvox.delta.x[i] = voxel->delta.x[i] / (double)naxes->x[i];
		subvox.min.x[i] = voxel->min.x[i] + (double)idx->x[i] * delta;
		subvox.max.x[i] = voxel->min.x[i] + (double)(idx->x[i] + 1) * delta;
		subvox.cen.x[i] = subvox.min.x[i] + 0.5 * delta; /* This is only valid if the gridding is uniform */
	}

	return subvox;
}

/*----------------------------------------------------------------------------*/

GeCam GeCam_Init(double phix, double phiy, double phiz)
/* Set plot bounds according to voxel and rotation for camera */
{
	GeCam cam = GeCam_INIT(phix, phiy, phiz);

	return cam;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Rotate(const GeVec3_d *vec, const GeCam *cam)
{
	GeVec3_d result;

	result = *vec;
	result = GeVec3_Rotate_x(&result, GeVec3_X(cam->phi, 0));
	result = GeVec3_Rotate_y(&result, GeVec3_X(cam->phi, 1));
	result = GeVec3_Rotate_z(&result, GeVec3_X(cam->phi, 2));

	return result;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_d_Init(double x, double y, double z)
{
	GeVec3_d vec = GeVec3_INIT(x, y, z);

	return vec;
}

/*----------------------------------------------------------------------------*/

GeVec3_s GeVec3_s_Init(size_t x, size_t y, size_t z)
{
	GeVec3_s vec = GeVec3_INIT(x, y, z);

	return vec;
}

/*----------------------------------------------------------------------------*/

double GeVec3_Mag(const GeVec3_d *a)
/* Calculate the magnitude of <a> = |<a>| */
{
	size_t i;
	double mag = 0;

	for(i = 0; i < 3; i++) {
		mag += pow(GeVec3_X(*a, i), 2.0);
	}

	return sqrt(mag);
}

/*----------------------------------------------------------------------------*/

double GeVec3_Mag2(const GeVec3_d *a, const GeVec3_d *b)
/* Calculate the magnitude of <b> - <a> = |<b> - <a>| */
{
	GeVec3_d c;

	c = GeVec3_Sub(a, b);

	return GeVec3_Mag(&c);
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Add(const GeVec3_d *a, const GeVec3_d *b)
/* Calculate the result of <c> = <a> + <b> */
{
	size_t i;
	GeVec3_d c = GeVec3_INIT(0,0,0);

	for(i = 0; i < 3; i++)
		c.x[i] = a->x[i] + b->x[i];
	
	return c;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Sub(const GeVec3_d *a, const GeVec3_d *b)
/* Calculate the result of <c> = <b> - <a> */
{
	size_t i;
	GeVec3_d c;

	for(i = 0; i < 3; i++)
		c.x[i] = b->x[i] - a->x[i];
	
	return c;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Normalize(const GeVec3_d *a)
/* Normalize <a> */
{
	GeVec3_d b;
	double mag = GeVec3_Mag(a);
	size_t i;

	for(i = 0; i < 3; i++) {
		GeVec3_X(b, i) = GeVec3_X(*a, i) / mag;
	}

	return b;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Scale(const GeVec3_d *a, double fac)
/* Scale <a> by fac, i.e. <b> = fac * <a> */
{
	size_t i;
	GeVec3_d b;

	Mem_BZERO(&b);

	for(i = 0; i < 3; i++) {
		GeVec3_X(b, i) = fac * GeVec3_X(*a, i);
	}

	return b;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_InterpLinear(const GeVec3_d *xa, const GeVec3_d *xb, const GeVec3_d *a, 
	const GeVec3_d *b, const GeVec3_d *pos)
/* Interpolate linearly between <a> and <b>, i.e. infer value at pos on each
 * axis according to
 * 	result_i = a_i + m_i * (pos_i - xa_i)
 *
 * 	and
 *
 * 	m_i = (b_i - a_i) / (xb_i - xa_i) -- if |xb_i - xa_i| > 0
 * 	      = 0                           -- otherwise
 *
 * 	where origin_i = ith component of origin
 * 	      b_i and a_i = ith component of <a> and <b>
 * 	      xa_i and xb_i = ith component of positions of <a> and <b>
 * 	      pos_i = ith component of interpolation position
 */
{
	size_t i;
	double m, delta_x;
	//const double *xav = xa->x, *xbv = xb->x, *av = a->x, *bv = b->x, *posv = pos->x;
	GeVec3_d result;

	for(i = 0; i < 3; i++) {
		/* Calculate delta_x */
		delta_x = (GeVec3_X(*xb, i) - GeVec3_X(*xa, i));
		//delta_x = xbv[i] - xav[i];

		/* Calculate slope */
		m = fabs(delta_x) > 0 ? (GeVec3_X(*b, i) - GeVec3_X(*a, i)) / delta_x : 0;
		//m = fabs(delta_x) > 0 ? (bv[i] - av[i]) / delta_x : 0;

		/* Calculate linearly interpolated value */
		GeVec3_X(result, i) = GeVec3_X(*a, i) + m * (GeVec3_X(*pos, i) - GeVec3_X(*xa, i));
		//GeVec3_X(result, i) = av[i] + m * (posv[i] - xav[i]);
	}

	return result;
}

/*----------------------------------------------------------------------------*/

double GeVec3_DotProd(const GeVec3_d *a, const GeVec3_d *b)
/* Calculate prod = <a> dot <b> */
{
	size_t i;
	double prod = 0;

	for(i = 0; i < 3; i++)
		prod += a->x[i] * b->x[i];

	return prod;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_MatOp(const GeVec3_d *vec, const GeMat3_d *mat)
/* Calculate <result> = [mat]<vec> */
{
	size_t i, j;
	GeVec3_d result = GeVec3_INIT(0, 0, 0);

	for(i = 0; i < 3; i++) {
		for(j = 0; j < 3; j++) {
			result.x[i] += GeMat3_X(*mat, i, j) * vec->x[j];
		}
	}

	return result;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Rotate_x(const GeVec3_d *vec, double phi)
/*
Rotate vector phi radians about x axis
Rotation matrix about x:
	1  	       0          0
	0 	cos(phi)  -sin(phi)
	0 	sin(phi)   cos(phi)
*/
{
	GeMat3_d matrix;

	GeMat3_X(matrix, 0, 0) = 1;
	GeMat3_X(matrix, 0, 1) = 0;
	GeMat3_X(matrix, 0, 2) = 0;

	GeMat3_X(matrix, 1, 0) = 0;
	GeMat3_X(matrix, 1, 1) = cos(phi);
	GeMat3_X(matrix, 1, 2) = -sin(phi);

	GeMat3_X(matrix, 2, 0) = 0;
	GeMat3_X(matrix, 2, 1) = sin(phi);
	GeMat3_X(matrix, 2, 2) = cos(phi);
	
	return GeVec3_MatOp(vec, &matrix);
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Rotate_y(const GeVec3_d *vec, double phi)
/*
Rotate vector phi radians about y axis
Rotation matrix about y:
	cos(phi)  	0     sin(phi)
               0   	1 	     0
       -sin(phi) 	0     cos(phi)
*/
{
	GeMat3_d matrix;

	GeMat3_X(matrix, 0, 0) = cos(phi);
	GeMat3_X(matrix, 0, 1) = 0;
	GeMat3_X(matrix, 0, 2) = sin(phi);

	GeMat3_X(matrix, 1, 0) = 0;
	GeMat3_X(matrix, 1, 1) = 1;
	GeMat3_X(matrix, 1, 2) = 0;

	GeMat3_X(matrix, 2, 0) = -sin(phi);
	GeMat3_X(matrix, 2, 1) = 0;
	GeMat3_X(matrix, 2, 2) = cos(phi);
	
	return GeVec3_MatOp(vec, &matrix);
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeVec3_Rotate_z(const GeVec3_d *vec, double phi)
/*
Rotate vector phi radians about z axis
Rotation matrix about z:
	cos(phi)  -sin(phi)     0
        sin(phi)   cos(phi)     0
               0          0     1
*/
{
	GeMat3_d matrix;

	GeMat3_X(matrix, 0, 0) = cos(phi);
	GeMat3_X(matrix, 0, 1) = -sin(phi);
	GeMat3_X(matrix, 0, 2) = 0;

	GeMat3_X(matrix, 1, 0) = sin(phi);
	GeMat3_X(matrix, 1, 1) = cos(phi);
	GeMat3_X(matrix, 1, 2) = 0;

	GeMat3_X(matrix, 2, 0) = 0;
	GeMat3_X(matrix, 2, 1) = 0;
	GeMat3_X(matrix, 2, 2) = 1;
	
	return GeVec3_MatOp(vec, &matrix);
}

/*----------------------------------------------------------------------------*/

GeRay GeRay_Init(double ex, double ey, double ez, double dx, double dy, double dz)
{
	GeRay ray = GeRay_INIT(ex, ey, ez, dx, dy, dz);

	return ray;
}

/*----------------------------------------------------------------------------*/

double GeRay_IntersectPlane(const GeRay *ray, const GeVec3_d *n, const GeVec3_d *q)
/*
Calculate the intersection between ray and plane according to

       t = <n> dot (<q> - <e>) / <n> dot <d>

	where <n> is the normal vector,
	      <q> a vertex of the plane,
	      <e> the origin of the ray,
	  and <d> the direction of the ray
*/
{
	GeVec3_d q_m_e = GeVec3_Sub(&ray->e, q);

	return GeVec3_DotProd(n, &q_m_e) / GeVec3_DotProd(n, &ray->d);
}

/*----------------------------------------------------------------------------*/

void GeRay_IntersectSphere(const GeRay *ray, double r, double *t1, double *t2)
/*
Solve for the intersection between a ray
	<x> = <e> + <d> * t
and a sphere with radius R in Cartesian coordinates (where <e> is OUTSIDE
the sphere). The 3D equatin of a sphere is
	|<x>|^2 = R^2
resulting in
	|<e>|^2 + 2 * <d> dot <e> * t + |<d>|^2 * t^2 = R^2
and the intersection between a line and a sphere can be found by solving the
quadratic equaiton
	a * t^2 + b * t + c = 0
where
	a = |<d>|^2
	b = 2 * <e> dot <d>
	c = |<e>|^2 - R^2
*/
{
	double a, b, c;

	a = GeVec3_DotProd(&ray->d, &ray->d);
	b = 2.0 * GeVec3_DotProd(&ray->e, &ray->d);
	c = GeVec3_DotProd(&ray->e, &ray->e) - r * r;

	Num_QuadraticRoots(a, b, c, t1, t2);

	#if 0
	Deb_PRINT("solve: r=%g, t1=%g, t2=%g\n", r, *t1, *t2);
	Deb_PAUSE();
	#endif

	if(Num_ISNAN(*t1))
		*t1 = HUGE_VAL;

	if(Num_ISNAN(*t2))
		*t2 = HUGE_VAL;

	return;
}

/*----------------------------------------------------------------------------*/

GeRay GeRay_Inc(const GeRay *ray, double t)
{
	size_t i;
	GeRay newray = *ray;

	for(i = 0; i < 3; i++) {
		newray.e.x[i] += newray.d.x[i] * t;
	}

	return newray;
}

/*----------------------------------------------------------------------------*/

GeRay GeRay_Rotate(const GeRay *ray, int axis, double phi)
/* Rotate ray about x axis */
{
	GeRay ray2 = GeRay_INIT(0, 0, 0, 0, 0, 0);

	switch(axis) {
		case 0:
			ray2.e = GeVec3_Rotate_x(&ray->e, phi);
			ray2.d = GeVec3_Rotate_x(&ray->d, phi);
			break;

		case 1:
			ray2.e = GeVec3_Rotate_y(&ray->e, phi);
			ray2.d = GeVec3_Rotate_y(&ray->d, phi);
			break;

		case 2:
			ray2.e = GeVec3_Rotate_z(&ray->e, phi);
			ray2.d = GeVec3_Rotate_z(&ray->d, phi);
			break;

		default:
			/* Not a valid axis */
			Deb_ASSERT(0);
	}

	return ray2;
}

/*----------------------------------------------------------------------------*/

int GeRay_IntersectVoxel(const GeRay *ray, const GeVox *voxel, double *tmin, size_t *side)
/* Find the intersection of a ray OUTSIDE voxel in rectangular coordinates. */
{
	int hit = 0;

	switch(voxel->geom) {
		case GEOM_SPH1D:
			hit = GeRay_IntersectVoxel_sph1d(ray, voxel, tmin, side);
			break;

		case GEOM_REC3D:
			hit = GeRay_IntersectVoxel_rec3d(ray, voxel, tmin, side);
			break;

		default: /* Shouldn't happen */
			Deb_ASSERT(0);
	}

	return hit;
}

/*----------------------------------------------------------------------------*/

int GeRay_IntersectVoxel_sph1d(const GeRay *ray, const GeVox *voxel, double *tmin, size_t *side)
/*
Solve for intersection between ray and voxel in which ray is OUTSIDE of voxel.

A 1D spherical voxel is described by two concentric spheres, thus for a ray
to intersect the voxel, it merely needs to hit the outer sphere.

side=0 --> inner sphere
side=1 --> outer sphere

If there is a hit, side would always be 1 for this routine.
*/
{
	double r = GeVec3_X(voxel->max, 0), t1, t2;

	GeRay_IntersectSphere(ray, r, &t1, &t2);
	
	if(t1 < t2)
		*tmin = t1;
	else
		*tmin = t2;

	*side = 1;

	return (*tmin < HUGE_VAL ? 1 : 0);
}

/*----------------------------------------------------------------------------*/

int GeRay_IntersectVoxel_rec3d(const GeRay *ray, const GeVox *voxel, double *tmin, size_t *side)
/* Find the intersection of a ray OUTSIDE voxel in rectangular coordinates. */
{
	double t;
	size_t i;
	int within_box;
	static GeVec3_d normal[6] = {
		GeVec3_INIT(-1,  0,  0),
		GeVec3_INIT( 1,  0,  0),
		GeVec3_INIT( 0, -1,  0),
		GeVec3_INIT( 0,  1,  0),
		GeVec3_INIT( 0,  0, -1),
		GeVec3_INIT( 0,  0,  1)
	};
	const GeVec3_d *q = NULL;
	GeRay tstray = GeRay_INIT(0, 0, 0, 0, 0, 0);

	/* Init tmin */
	*tmin = HUGE_VAL;

	/* debug */
	for(i = 0; i < 6; i++) {
		/* Calculate intersections with side */
		q = i % 2 == 0 ? &voxel->min : &voxel->max;
		t = GeRay_IntersectPlane(ray, &normal[i], q);

		/* Check if intersection is inside box */
		tstray = GeRay_Inc(ray, t);
		within_box = point_in_voxel2(&tstray.e, voxel, i / 2);

		/* Find tmin if intersection is within box*/
		if(within_box && (t < *tmin)) {
			*tmin = t;
			*side = i;
		}
	}
	
	return (*tmin < HUGE_VAL ? 1 : 0);
}

/*----------------------------------------------------------------------------*/

int point_in_voxel2(const GeVec3_d *pt, const GeVox *voxel, size_t axis)
/* Check if coordinates of pt NOT on axis are within the limits of the voxel */
{
	size_t i;
	int within_box = 1;

	for(i = 0; i < 3; i++) {
		if(i != axis) {
			if((GeVec3_X(*pt, i) < GeVec3_X(voxel->min, i)) || (GeVec3_X(*pt, i) > GeVec3_X(voxel->max, i))) {
				within_box = 0;
				break;
			}
		}
	}

	return within_box;
}

/*----------------------------------------------------------------------------*/

void GeRay_TraverseVoxel(const GeRay *ray, const GeVox *voxel, double *tmin, size_t *side)
{
	switch(voxel->geom) {
		case GEOM_SPH1D:
			GeRay_TraverseVoxel_sph1d(ray, voxel, tmin, side);
			break;

		case GEOM_REC3D:
			GeRay_TraverseVoxel_rec3d(ray, voxel, tmin, side);
			break;

		default: /* Shouldn't happen */
			Deb_ASSERT(0);
	}

	return;
}

/*----------------------------------------------------------------------------*/

void GeRay_TraverseVoxel_sph1d(const GeRay *ray, const GeVox *voxel, double *tmin, size_t *side)
/*
Traverse a spherical shell voxel by calculating intersections with its inner
and outer spheres. Since the ray must originate from INSIDE the sphere1d voxel,
the larger distance of the outer sphere should be used, while the smaller of the
innter sphere should be used.

Side 0: inner sphere
Side 1: outer sphere
*/
{
	double t1, t2, t_in = HUGE_VAL, t_out = HUGE_VAL,
	       r_in = GeVec3_X(voxel->min, 0), r_out = GeVec3_X(voxel->max, 0);

	/* Find intersections with outer sphere */
	GeRay_IntersectSphere(ray, r_out, &t1, &t2);

	//Deb_PRINT("outer: t1=%g, t2=%g\n", t1, t2);

	t_out = (t1 > t2 ? t1 : t2);

	if(t_out <= 0)
		t_out = HUGE_VAL;

	/* Find intersection with inner sphere if r_in > 0 */
	if(r_in > 0) {
		GeRay_IntersectSphere(ray, r_in, &t1, &t2);

		//Deb_PRINT("inner: t1=%g, t2=%g\n", t1, t2);

		t_in = (t1 < t2 ? t1 : t2);

		if(t_in <= 0)
			t_in = HUGE_VAL;
	}

	Deb_ASSERT((t_in < HUGE_VAL) || (t_out < HUGE_VAL));

	/* Find final intersection */
	if(t_in < t_out) {
		*tmin = t_in;
		*side = 0;
	}
	else {
		*tmin = t_out;
		*side = 1;
	}

	return;
}

/*----------------------------------------------------------------------------*/

void GeRay_TraverseVoxel_rec3d(const GeRay *ray, const GeVox *voxel, double *tmin, size_t *side)
/*
Traverse a rectangular voxel using a variant of the Amanatides-Woo algorithm. An
intersection is ALWAYS guranteed, since we're traveling out of a bounded volume.
	* sides 0 & 1: x axis
	* sides 2 & 3: y axis
	* sides 4 & 5: z axis
*/
{
	double t;
	size_t i, iside;
	static const GeVec3_d normal[6] = {
		GeVec3_INIT(-1,  0,  0),
		GeVec3_INIT( 1,  0,  0),
		GeVec3_INIT( 0, -1,  0),
		GeVec3_INIT( 0,  1,  0),
		GeVec3_INIT( 0,  0, -1),
		GeVec3_INIT( 0,  0,  1)
	};
	const GeVec3_d *q = NULL;

	/* Init tmin */
	*tmin = HUGE_VAL;

	for(i = 0; i < 3; i++) {
		/*
		Calculate intersections with planes on all 3 axes
	          i == 0: x axis
		  i == 1: y axis
		  i == 2: z axis
		*/
		if(GeRay_D(*ray, i) == 0.0) {
			/* GeRay does not intersect either plane on this axis */
			continue;
		}
		else {
			if(GeRay_D(*ray, i) > 0) {
				iside = i * 2 + 1;
				q = &voxel->max;
			}
			else {
				iside = i * 2;
				q = &voxel->min;
			}
			t = GeRay_IntersectPlane(ray, &normal[iside], q);

			/* Find tmin */
			if(t < *tmin) {
				*tmin = t;
				*side = iside;
			}
		}

		#if 0 //debug
		debug_printf("D="); GeVec3_PRINT(stdout, ray->d); printf("\n");
		debug_printf("iside=%d, t=%g\n", iside, t);
		#endif
	}

	return;
}

/*----------------------------------------------------------------------------*/

/* This samples a random number uniformly in the
 * interval [0, 1) */
#define RAND()\
	gsl_rng_uniform(rng)
/* This samples a random number uniformly in the
 * interval (0, 1) */
#define PRAND()\
	gsl_rng_uniform_pos(rng)

GeRay GeRay_Rand(gsl_rng *rng, const GeVox *voxel)
{
	GeRay ray;

	switch(voxel->geom) {
		case GEOM_SPH1D:
			ray = GeRay_Rand_sph1d(rng, voxel);
			break;

		case GEOM_REC3D:
			ray = GeRay_Rand_rec3d(rng, voxel);
			break;

		default: /* Shouldn't reach here */
			Deb_PRINT("Uh oh, voxel->geom holds an unidentified geometry code '%d'\n", voxel->geom);
			Deb_ASSERT(0);
	}

	return ray;
}

/*----------------------------------------------------------------------------*/

GeRay GeRay_Rand_sph1d(gsl_rng *rng, const GeVox *voxel)
{
	GeRay ray;
	double
		r, phi, cost, sint,
		r_in = GeVec3_X(voxel->min, 0),
		r_out = GeVec3_X(voxel->max, 0);

	#define ONE_THIRD (0.3333333333333333)

	/* Calculate random ray origin in spherical coordinates */
	if(r_in > 0) {
		r = r_in * pow((1.0 + PRAND() * (pow(r_out/r_in, 3.0) - 1.0)), ONE_THIRD);
	}
	else {
		r = r_out * pow(PRAND(), ONE_THIRD);
	}
	
	#undef ONE_THIRD

	/* Reset ray */
	Mem_BZERO(&ray);

	/* Since this is a 1D problem, starting every ray from the
	   +Z axis is good enough */
	GeRay_E(ray, 2) = r;

	/* Generate random 3D direction */
	Num_RanDir3D(rng, &cost, &sint, &phi);

	/* Convert to rectangular coordinates */
	GeRay_D(ray, 0) = sint * cos(phi);
	GeRay_D(ray, 1) = sint * sin(phi);
	GeRay_D(ray, 2) = cost;

	return ray;
}

/*----------------------------------------------------------------------------*/

GeRay GeRay_Rand_rec3d(gsl_rng *rng, const GeVox *voxel)
/* Generate a randomly directed ray starting from a random position within
   the voxel */
{
	GeRay ray;
	double phi, cost, sint;
	size_t i;

	/* Reset ray */
	Mem_BZERO(&ray);

	#if 1
	/* Set random ray origin in rectangular coordinates */
	for(i = 0; i < 3; i++) {
		GeRay_E(ray, i) = GeVec3_X(voxel->cen, i) + (RAND() - 0.5) * GeVec3_X(voxel->delta, i);
	}
	#else
	for(i = 0; i < 3; i++) {
		GeRay_E(ray, i) = GeVec3_X(voxel->min, i) + RAND() * GeVec3_X(voxel->delta, i);
	}
	#endif

	/* Generate random 3D direction */
	Num_RanDir3D(rng, &cost, &sint, &phi);

	/* Convert to rectangular coordinates */
	GeRay_D(ray, 0) = sint * cos(phi);
	GeRay_D(ray, 1) = sint * sin(phi);
	GeRay_D(ray, 2) = cost;

	return ray;
}

/*----------------------------------------------------------------------------*/

void GeVox_Cpgplot(const GeVox *voxel, const GeCam *cam)
{
	int idum;

	switch(voxel->geom) {
		case GEOM_SPH1D:
			cpgqfs(&idum);
			cpgsfs(2);
			GeVox_Cpgplot_sph1d(voxel);
			cpgsfs(idum);
			break;

		case GEOM_REC3D:
			GeVox_Cpgplot_rec(voxel, cam);
			break;

		default: /* Shouldn't happen */
			Deb_ASSERT(0);
	}

	return;
}

/*----------------------------------------------------------------------------*/

static void GeVox_Cpgplot_sph1d(const GeVox *voxel)
/* Draw a circle to represent projection/cross section of sphere */
{
	Cpg_Circ(0.0, 0.0, GeVec3_X(voxel->max, 0));

	return;
}

/*----------------------------------------------------------------------------*/

static void GeVox_Cpgplot_rec(const GeVox *voxel, const GeCam *cam)
/*
            Z
	    |
	    |
	    |     /
	    4----------7
	   /|   /     /|
	  / |  /     / |
	 /  | /     /  |
	5----------6   |  
--------|---0------|---3---------Y
	|  /|      |  /
	| / |      | /
	|/  |      |/
	1----------2
       /    |
      /     |
     /
    X

  point 0: (x_min, y_min, z_min)
  point 6: (x_max, y_max, z_max)

*/
{
	size_t i;
	GeVec3_d min = voxel->min, max = voxel->max;
	GeVec3_d verts[8];

	verts[0] = min;
	verts[1] = min; verts[1].x[1] = GeVec3_X(max, 1);
	verts[2] = max; verts[2].x[2] = GeVec3_X(min, 2);
	verts[3] = min; verts[3].x[0] = GeVec3_X(max, 0);

	verts[4] = min; verts[4].x[2] = GeVec3_X(max, 2);
	verts[5] = max; verts[5].x[0] = GeVec3_X(min, 0);
	verts[6] = max;
	verts[7] = max; verts[7].x[1] = GeVec3_X(min, 1);

	for(i = 0; i < 4; i++) {
		GeVec3_Cpgline2(&verts[i], &verts[(i+1)%4], cam); /* lower plane */
		GeVec3_Cpgline2(&verts[4+i], &verts[4+(i+1)%4], cam); /* upper plane */
		GeVec3_Cpgline2(&verts[i], &verts[i+4], cam); /* sides */
	}

	return;
}

/*----------------------------------------------------------------------------*/

size_t GeVox_VertIndex2Pos(size_t i, size_t j, size_t k)
/* 
            Z
	    |
	    |
	    |     /
	    4----------7
	   /|   /     /|
	  / |  /     / |
	 /  | /     /  |
	5----------6   |  
--------|---0------|---3---------Y
	|  /|      |  /
	| / |      | /
	|/  |      |/
	1----------2
       /    |
      /     |
     /
    X
 *
 * k | 0 1 0 1 0 1 0 1
 * j | 0 0 1 1 0 0 1 1
 * i | 0 0 0 0 1 1 1 1
 */
{
	static size_t pos[8] = {
		0, /* (0, 0, 0) */
		4, /* (0, 0, 1) */
		3, /* (0, 1, 0) */
		7, /* (0, 1, 1) */
		1, /* (1, 0, 0) */
		5, /* (1, 0, 1) */
		2, /* (1, 1, 0) */
		6, /* (1, 1, 1) */
	};

	return pos[k + 2 * (j + 2 * i)];
}

/*----------------------------------------------------------------------------*/

void GeVec3_Cpgpt1(const GeVec3_d *vec, int sty, const GeCam *cam)
/* By default project on y-z plane */
{
	GeVec3_d v;

	if(cam) {
		v = GeVec3_Rotate(vec, cam);
	}
	else {
		v = *vec;
	}

	Cpg_Pt1(GeVec3_X(v, 1), GeVec3_X(v, 2), sty);

	return;
}

/*----------------------------------------------------------------------------*/

void GeVec3_Cpgline2(const GeVec3_d *v1, const GeVec3_d *v2, const GeCam *cam)
/* By default project on y-z plane */
{
	float xbuf[2], zbuf[2];
	GeVec3_d v11, v22;
	
	/* Optionally rotate coordinates */
	if(cam) {
		v11 = GeVec3_Rotate(v1, cam);
		v22 = GeVec3_Rotate(v2, cam);
	}
	else {
		v11 = *v1;
		v22 = *v2;
	}

	xbuf[0] = (float)v11.x[1];
	xbuf[1] = (float)v22.x[1];
	zbuf[0] = (float)v11.x[2];
	zbuf[1] = (float)v22.x[2];

	cpgline(2, xbuf, zbuf);

	return;
}

/*----------------------------------------------------------------------------*/

void GeVec3_Cpgarro2(const GeVec3_d *v1, const GeVec3_d *v2, const GeCam *cam)
/* By default project on y-z plane */
{
	GeVec3_d v11, v22;

	if(cam) {
		v11 = GeVec3_Rotate(v1, cam);
		v22 = GeVec3_Rotate(v2, cam);
	}
	else {
		v11 = *v1;
		v22 = *v2;
	}

	Cpg_Arro(v11.x[1], v11.x[2], v22.x[1], v22.x[2]);

	return;
}

/*----------------------------------------------------------------------------*/

void GeRay_Cpgarro(const GeRay *ray, const GeCam *cam)
/* Plot ray as an arrow according to origin and direction vector */
{
	size_t i;
	GeVec3_d head = GeVec3_INIT(0, 0, 0);

	for(i = 0; i < 3; i++)
		head.x[i] = ray->e.x[i] + ray->d.x[i];

	GeVec3_Cpgarro2(&ray->e, &head, cam);

	return;
}

/*----------------------------------------------------------------------------*/

void GeVox_Cpgenv(const GeVox *voxel)
/* Set size of plotting window according to voxel size
 * default is to plot on y-z plane!!! */
{
	const double
		*min = voxel->min.x,
	      	*max = voxel->max.x,
	      	dx = max[1]-min[1],
	      	dz = max[2]-min[2];

	switch(voxel->geom) {
		case GEOM_SPH1D:
			Cpg_Env(-max[0]*1.1, max[0]*1.1, -max[0]*1.1, max[0]*1.1, 1, 0);
			break;

		case GEOM_REC3D:
			Cpg_Env(min[1]-dx*1.5, max[1]+dx*0.5, min[2]-dz*1.5, max[2]+dz*0.5, 1, 0);
			break;

		default: /* Shouldn't happen */
			Deb_ASSERT(0);
	}

	return;
}

/*----------------------------------------------------------------------------*/

GeVox GeVox_Init(int geom, double xmin, double ymin, double zmin, double xmax, double ymax, double zmax)
{
	GeVox vox = GeVox_INIT(geom, xmin, ymin, zmin, xmax, ymax, zmax);

	return vox;
}

/*----------------------------------------------------------------------------*/

GeVox GeVox_Init2(int geom, GeVec3_d min, GeVec3_d max)
{
	GeVox vox = GeVox_INIT(
		geom,
		GeVec3_X(min, 0),
		GeVec3_X(min, 1),
		GeVec3_X(min, 2),
		GeVec3_X(max, 0),
		GeVec3_X(max, 1),
		GeVec3_X(max, 2)
	);

	return vox;
}

/*----------------------------------------------------------------------------*/

void GeRay_AWInit(GeRay *ray, const GeVox *voxel)
{
	double t;
	size_t i, iplane;
	static const GeVec3_d normal[6] = {
		GeVec3_INIT(-1,  0,  0),
		GeVec3_INIT( 1,  0,  0),
		GeVec3_INIT( 0, -1,  0),
		GeVec3_INIT( 0,  1,  0),
		GeVec3_INIT( 0,  0, -1),
		GeVec3_INIT( 0,  0,  1)
	};
	const GeVec3_d *q = NULL;

	for(i = 0; i < 3; i++) {
		/*
		Calculate intersections with planes on all 3 axes
	          i == 0: x axis
		  i == 1: y axis
		  i == 2: z axis
		*/
		if(GeRay_D(*ray, i) == 0.0) {
			/* GeRay does not intersect either plane on this axis */
			GeVec3_X(ray->tMax, i) = HUGE_VAL;
			GeVec3_X(ray->tDelta, i) = 0;
			continue;
		}
		else {
			if(GeRay_D(*ray, i) > 0) {
				iplane = i * 2 + 1;
				q = &voxel->max;
			}
			else {
				iplane = i * 2;
				q = &voxel->min;
			}
			t = GeRay_IntersectPlane(ray, &normal[iplane], q);

			/* Set tMax for this axis */
			GeVec3_X(ray->tMax, i) = t;

			/* Calculate tDelta */
			GeVec3_X(ray->tDelta, i) = GeVec3_X(voxel->delta, i) / fabs(GeVec3_X(ray->d, i));
		}
	}

	return;
}

/*----------------------------------------------------------------------------*/

void GeRay_AWTraverse(GeRay *ray, double *dt, size_t *plane)
{
	double tmin;

	#define tMaxX (GeVec3_X(ray->tMax, 0))
	#define tMaxY (GeVec3_X(ray->tMax, 1))
	#define tMaxZ (GeVec3_X(ray->tMax, 2))
	#define tDeltaX (GeVec3_X(ray->tDelta, 0))
	#define tDeltaY (GeVec3_X(ray->tDelta, 1))
	#define tDeltaZ (GeVec3_X(ray->tDelta, 2))

	if(tMaxX < tMaxY) {
		if(tMaxX < tMaxZ) {
			if(GeRay_D(*ray, 0) > 0) {
				*plane = 1;
			}
			else {
				*plane = 0;
			}
			tmin = tMaxX;
			tMaxX += tDeltaX;
		}
		else {
			if(GeRay_D(*ray, 2) > 0) {
				*plane = 5;
			}
			else {
				*plane = 4;
			}
			tmin = tMaxZ;
			tMaxZ += tDeltaZ;
		}
	}
	else {
		if(tMaxY < tMaxZ) {
			if(GeRay_D(*ray, 1) > 0) {
				*plane = 3;
			}
			else {
				*plane = 2;
			}
			tmin = tMaxY;
			tMaxY += tDeltaY;
		}
		else {
			if(GeRay_D(*ray, 2) > 0) {
				*plane = 5;
			}
			else {
				*plane = 4;
			}
			tmin = tMaxZ;
			tMaxZ += tDeltaZ;
		}
	}

	*dt = tmin - ray->t;
	ray->t = tmin;

	return;
}

/*----------------------------------------------------------------------------*/

GeVec3_d GeRay_AWPos(const GeRay *ray)
/* Calculate current position based on t and ray origin */
{
	GeRay tmp_ray;

	tmp_ray = GeRay_Inc(ray, ray->t);

	return tmp_ray.e;
}





