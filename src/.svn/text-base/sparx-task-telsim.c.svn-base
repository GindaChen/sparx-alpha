#include "sparx.h"

/* Global parameter struct */
static struct glb {
	int test, cont;
	DatINode *unit;
	double ucon;
	MirImg_Axis x, y, v;
	MirImg *xyv_img, *tau_img;
	double dist, rotate[3], I_norm, I_cmb;
	char *imgname;
	MirFile *xyv_imgf, *tau_imgf;
	SpModel model;
	size_t line;
	double lamb, freq;
	size_t nsubres;
	struct {
		double blc_x, blc_y, trc_x, trc_y;
		size_t nsub;
	} *subres;
} glb;

enum {
	UNIT_K,
	UNIT_JYPX
};

static DatINode UNITS[] = {
	{"K", UNIT_K},
	{"JY/PIXEL", UNIT_JYPX},
	{0, 0}
};

/* Subroutine prototypes */
static int InitModel(void);
static void *InitModelThread(void *tid_p);
static int CalcImage(void);
static void *CalcImageThread(void *tid_p);
static void RadiativeXfer(double dx, double dy, double *I_nu, double *tau_nu);

/*----------------------------------------------------------------------------*/

int SpTask_Telsim(void)
{
	size_t i;
	int sts = 0;
	PyObject *o, *o1, *o2;

	/*
	 * Inputs
	 */
	/* Reset parms */
	Mem_BZERO(&glb);

	/* npix */
	if(!sts && !(sts = SpPy_GetInput_PyObj("npix", &o))) {
		glb.x.n = Sp_PYSIZE(Sp_PYLST(o, 0));
		glb.x.crpix = MirWr_CRPIX(glb.x.n);
		glb.y.n = Sp_PYSIZE(Sp_PYLST(o, 1));
		glb.y.crpix = MirWr_CRPIX(glb.y.n);
		SpPy_XDECREF(o);
	}

	/* cell */
	if(!sts && !(sts = SpPy_GetInput_PyObj("cell", &o))) {
		glb.x.delt = Sp_PYDBL(Sp_PYLST(o, 0));
		glb.y.delt = Sp_PYDBL(Sp_PYLST(o, 1));
		SpPy_XDECREF(o);
	}

	/* chan */
	if(!sts && !(sts = SpPy_GetInput_PyObj("chan", &o))) {
		glb.v.n = Sp_PYSIZE(Sp_PYLST(o, 0));
		glb.v.crpix = MirWr_CRPIX(glb.v.n);
		glb.v.delt = Sp_PYDBL(Sp_PYLST(o, 1));
		SpPy_XDECREF(o);
	}

	/* rotate */
	if(!sts && !(sts = SpPy_GetInput_PyObj("rotate", &o))) {
		glb.rotate[0] = Sp_PYDBL(Sp_PYLST(o, 0));
		glb.rotate[1] = Sp_PYDBL(Sp_PYLST(o, 1));
		glb.rotate[2] = Sp_PYDBL(Sp_PYLST(o, 2));
		SpPy_XDECREF(o);
	}

	/* subres */
	if(!sts && !(sts = SpPy_GetInput_PyObj("subres", &o))) {
		if(o != Py_None) {
			/* Get number of boxes */
			glb.nsubres = (size_t)PyList_Size(o);
			glb.subres = Mem_CALLOC(glb.nsubres, glb.subres);
			for(i = 0; i < glb.nsubres; i++) {
				o1 = PyList_GetItem(o, (Py_ssize_t)i);
				glb.subres[i].blc_x = Sp_PYDBL(PyList_GetItem(o1, (Py_ssize_t)0));
				glb.subres[i].blc_y = Sp_PYDBL(PyList_GetItem(o1, (Py_ssize_t)1));
				glb.subres[i].trc_x = Sp_PYDBL(PyList_GetItem(o1, (Py_ssize_t)2));
				glb.subres[i].trc_y = Sp_PYDBL(PyList_GetItem(o1, (Py_ssize_t)3));
				glb.subres[i].nsub = Sp_PYSIZE(PyList_GetItem(o1, (Py_ssize_t)4));
			}
		}
		SpPy_XDECREF(o);
	}

	/* source */
	if(!sts) {
		sts = SpPy_GetInput_model("source", &glb.model);
	}

	/* obs */
	if(!sts && !(sts = SpPy_GetInput_PyObj("obs", &o))) {
		o1 = PyObject_GetAttrString(o, "cont");
		o2 = PyObject_GetAttrString(o, "data");
		/* Temporary measure */
		Deb_ASSERT(o1 != NULL);
		Deb_ASSERT(o2 != NULL);
		glb.cont = Sp_PYINT(o1);
		if(glb.cont) {
			glb.lamb = Sp_PYDBL(o2);
			glb.freq = PHYS_CONST_MKS_LIGHTC / glb.lamb;
		}
		else {
			Deb_ASSERT(glb.model.parms.mol != NULL);
			glb.line = Sp_PYSIZE(o2);
			glb.freq = glb.model.parms.mol->rad[glb.line]->freq;
			glb.lamb = PHYS_CONST_MKS_LIGHTC / glb.freq;
			Deb_ASSERT(glb.line < glb.model.parms.mol->nrad);
		}
		SpPy_XDECREF(o1);
		SpPy_XDECREF(o2);
		SpPy_XDECREF(o);
	}

	if(!sts && !(sts = SpPy_GetInput_PyObj("unit", &o))) {
		/* unit */
		glb.unit = Dat_IList_NameLookup(UNITS, Sp_PYSTR(o));
		Deb_ASSERT(glb.unit != NULL);
		if(glb.unit->idx == UNIT_K)
			glb.ucon = Phys_RayleighJeans(glb.freq, 1.0);
		else if(glb.unit->idx == UNIT_JYPX)
			glb.ucon = (PHYS_UNIT_MKS_JY / (glb.x.delt * glb.y.delt));
		else
			Deb_ASSERT(0);
		/* Sanity check */
		Deb_ASSERT((glb.ucon > 0) && (!Num_ISNAN(glb.ucon)) && (glb.ucon < HUGE_VAL));
		SpPy_XDECREF(o);

	}
	/* dist */
	if(!sts) sts = SpPy_GetInput_dbl("dist", &glb.dist);

	/* out (mandatory) */
	if(!sts) sts = SpPy_GetInput_mirxy_new("out", glb.x.n, glb.y.n, glb.v.n, &glb.xyv_imgf);

	/* tau (optional) */
	if(!sts && SpPy_CheckOptionalInput("tau")) {
		sts = SpPy_GetInput_mirxy_new("tau", glb.x.n, glb.y.n, glb.v.n, &glb.tau_imgf);
	}

	/*
	 * Initialize model
	 */
	if(!sts) sts = InitModel();

	/*
	 * Synthesize image
	 */
	if(!sts) {
		/* Allocate image */
		glb.xyv_img = MirImg_Alloc(glb.x, glb.y, glb.v);
		glb.xyv_img->restfreq = glb.freq;

		if(glb.tau_imgf)
			glb.tau_img = MirImg_Alloc(glb.x, glb.y, glb.v);

		/* Calculate image */
		sts = CalcImage();
	}

	if(!sts) {
		/* Denormalize and convert image to proper units, then write cube to
		   Miriad image dataset */
		MirImg_WriteXY(glb.xyv_imgf, glb.xyv_img, glb.unit->name, glb.I_norm/glb.ucon);
		//MirWr_WriteImgCube(glb.xyv_imgf->tno, &glb.x, &glb.y, &glb.v, glb.unit->name, glb.I_norm/glb.ucon, glb.cube);

		if(glb.tau_imgf)
			MirImg_WriteXY(glb.tau_imgf, glb.tau_img, "Optical depth", 1.0);
	}

	if(!sts)
		Sp_PRINT("Wrote Miriad image to `%s'\n", glb.xyv_imgf->name);

	/*
	 * Cleanup
	 */
	if(glb.xyv_img)
		MirImg_Free(glb.xyv_img);

	if(glb.tau_img)
		MirImg_Free(glb.tau_img);

	if(glb.imgname)
		free(glb.imgname);

	if(glb.subres)
		free(glb.subres);

	SpModel_Cleanup(glb.model);

	/* Miriad images must always be closed! */
	if(glb.xyv_imgf)
		MirXY_Close(glb.xyv_imgf);

	if(glb.tau_imgf)
		MirXY_Close(glb.tau_imgf);

	return sts;
}

/*----------------------------------------------------------------------------*/

static int InitModel(void)
{
	Zone *root = glb.model.grid, *zp;
	SpPhys *pp;
	int sts = 0;

	/* Set normalization intensity to 20K -- normalization prevents rounding
	   errors from creeping in when flux values are very small */
	glb.I_norm = Phys_PlanckFunc(glb.freq, 20.0);
	Deb_ASSERT(glb.I_norm > 0); /* Just in case */

	/* Calculate CMB intensity */
	if(glb.model.parms.T_cmb > 0) {
		glb.I_cmb = Phys_PlanckFunc(glb.freq, glb.model.parms.T_cmb);
		Deb_ASSERT(glb.I_cmb > 0); /* Just in case */

		/* Normalize CMB */
		glb.I_cmb /= glb.I_norm;
	}

	for(zp = Zone_GetMinLeaf(root); zp; zp = Zone_AscendTree(zp)) {
		/* Pointer to physical parameters */
		pp = zp->data;

		if((pp->n_H2 > 0) && !zp->children) {
			/* This is a non-empty leaf zone */
			pp->non_empty_leaf = 1;

			if(pp->X_mol > 0) {
				/* This zone contains tracer molecules */
				pp->has_tracer = 1;
			}
		}
	}

	sts = SpUtil_Threads2(Sp_NTHREAD, InitModelThread);
	//SpUtil_Threads(InitModelThread);

	return sts;
}

/*----------------------------------------------------------------------------*/

static void *InitModelThread(void *tid_p)
{
	size_t tid = *((size_t *)tid_p), zone_id;
	Zone *root = glb.model.grid, *zp;
	SpPhys *pp;

	for(zp = Zone_GetMinLeaf(root), zone_id = 0; zp; zp = Zone_AscendTree(zp), zone_id++) {
		if(zone_id % Sp_NTHREAD == tid) {
			/* Check for thread termination */
			Sp_CHECKTERMTHREAD();

			/* Init zone parameters */
			pp = zp->data;

			if(glb.cont) {
				SpPhys_InitContWindows(pp, &glb.freq, (size_t)1);
			}
			else {
				pp->width = SpPhys_CalcLineWidth(pp);
			}

			/* Add dust emission/absorption if T_d > 0 */
			if(pp->T_d > 0) {
				SpPhys_AddContinuum_d(pp, glb.cont, glb.model.parms.gas_to_dust);
			}

			/* Add free-free emission/absorption if T_ff > 0 */
			if(pp->T_ff > 0) {
				SpPhys_AddContinuum_ff(pp, glb.cont);
			}

			/* Set continuum flux */
			if(pp->T_bb > 0) {
				//debug
				SpPhys_SetContinuumIntens_bb(pp, glb.cont, pp->T_bb, glb.I_norm);
				Deb_PRINT("T_bb=%g, F_nu=%g\n", pp->T_bb, pp->cont[0].I_bb);
			}
		}
	}

	pthread_exit(NULL);
}

/*----------------------------------------------------------------------------*/

static int CalcImage(void)
{
	return SpUtil_Threads2(Sp_NTHREAD, CalcImageThread);
}

/*----------------------------------------------------------------------------*/

static void *CalcImageThread(void *tid_p)
{
	size_t tid = *((size_t *)tid_p), pix_id, ix, iy, iv, nsub, isub, jsub, ibox;
	double dx, dy, subix, subiy, *I_sub, *I_nu, *tau_sub, *tau_nu;

	/* pix_id is used for distributing work to threads */
	pix_id = 0;

	for(ix = 0; ix < glb.x.n; ix++) {
		for(iy = 0; iy < glb.y.n; iy++) {
			if(pix_id % Sp_NTHREAD == tid) {
				/* Check for thread termination */
				Sp_CHECKTERMTHREAD();

				/* Determine angular offsets from the pointing center */
				dx = ((int)ix - (int)glb.x.crpix) * glb.x.delt;
				dy = ((int)iy - (int)glb.y.crpix) * glb.y.delt;

				/* nsub is by default 1 */
				nsub = 1;

				/* Check if position is within any of the subres boxes */
				for(ibox = 0; ibox < glb.nsubres; ibox++) {
					if((dx >= glb.subres[ibox].blc_x) && (dx <= glb.subres[ibox].trc_x) &&
					   (dy >= glb.subres[ibox].blc_y) && (dy <= glb.subres[ibox].trc_y)) {
						/* Position within subres box, set nsub to subres[ibox].nsub */
						nsub = glb.subres[ibox].nsub;
						break;
					}
				}

				/* I_nu is the brightness for all channels at pixel (ix, iy) */
				I_nu = Mem_CALLOC(glb.v.n, I_nu);

				/* tau_nu is the total optical depth for all channels at pixel (ix, iy) */
				tau_nu = Mem_CALLOC(glb.v.n, tau_nu);

				/* Loop through sub-resolution positions */
				for(isub = 0; isub < nsub; isub++) {
					for(jsub = 0; jsub < nsub; jsub++) {
						/* I_sub is the brightness for all channels at each sub-resolution */
						I_sub = Mem_CALLOC(glb.v.n, I_sub);
						tau_sub = Mem_CALLOC(glb.v.n, tau_sub);

						/* Determine sub-resolution angular offsets from the pointing center */
						subix = (double)ix + ((double)isub) / (double)nsub;
						subiy = (double)iy + ((double)jsub) / (double)nsub;
						dx = (subix - (double)glb.x.crpix) * glb.x.delt;
						dy = (subiy - (double)glb.y.crpix) * glb.y.delt;

						/* Calculate radiative transfer for this sub-los */
						RadiativeXfer(dx, dy, I_sub, tau_sub);

						/* Add I_sub to I_nu */
						for(iv = 0; iv < glb.v.n; iv++) {
							I_nu[iv] += I_sub[iv];
							tau_nu[iv] += tau_sub[iv];
						}

						/* Cleanup */
						free(I_sub);
						free(tau_sub);
					}
				}

				/* Save averaged I_nu to map */
				for(iv = 0; iv < glb.v.n; iv++) {
					MirImg_PIXEL(*glb.xyv_img, iv, ix, iy) = I_nu[iv] / (double)(nsub * nsub);

					if(glb.tau_img)
						MirImg_PIXEL(*glb.tau_img, iv, ix, iy) = tau_nu[iv] / (double)(nsub * nsub);
				}

				/* Cleanup */
				free(I_nu);
				free(tau_nu);
			}
			/* Increment pix_id */
			pix_id += 1;
		}
	}


	return NULL;
}

/*----------------------------------------------------------------------------*/

static void RadiativeXfer(double dx, double dy, double *I_nu, double *tau_nu)
{
	GeRay ray;
	double dv, theta, phi, t, vfac, j_nu, k_nu, S_nu, dtau_nu;
	SpPhys *pp;
	size_t iv, side;
	Zone *zp, *root = glb.model.grid;

	/* Reset ray */
	Mem_BZERO(&ray);

	/* Init ray position to <dist, 0, 0> */
	GeRay_E(ray, 0) = glb.dist / Sp_LENFAC;
	GeRay_E(ray, 1) = 0;
	GeRay_E(ray, 2) = 0;

	/* Set direction of ray according to pixel position:
	 *   theta = PI/2 + dy
	 *   phi = -dx
	 */
	phi = -dx;
	theta = (PI / 2.0) + dy;

	/* Convert to Cartesian coordinates */
	GeRay_D(ray, 0) = sin(theta) * cos(phi);
	GeRay_D(ray, 1) = sin(theta) * sin(phi);
	GeRay_D(ray, 2) = cos(theta);

	/* Rotate ray:
	 * Since what we REALLY want to rotate is the model and that the rays
	 * are pointed towards the model, rays should be rotated in the negative
	 * direction, and in the opposite order of what we would've done to
	 * rotate the model. */
	ray = GeRay_Rotate(&ray, 2, -glb.rotate[2]);
	ray = GeRay_Rotate(&ray, 1, -glb.rotate[1]);
	ray = GeRay_Rotate(&ray, 0, -glb.rotate[0]);

	/* Coordinate-dependent offset */
	switch(root->voxel.geom) {
		case GEOM_SPH1D:
			break;

		case GEOM_REC3D:
			ray.e = GeVec3_Add(&ray.e, &root->voxel.cen);
			break;

		default: /* Shouldn't reach here */
			Deb_ASSERT(0);
	}

	/* Reset tau for all channels */
	Mem_BZERO2(tau_nu, glb.v.n);

	/* Shoot ray at model and see what happens! */
	if(GeRay_IntersectVoxel(&ray, &root->voxel, &t, &side)) {
		/* Calculate intersection */
		ray = GeRay_Inc(&ray, t);

		/* Locate starting leaf zone according to intersection */
		zp = Zone_GetLeaf(root, side, &ray.e);

		/* Keep going until there's no next zone to traverse to */
		while(zp) {
			/* Calculate path to next boundary */
			GeRay_TraverseVoxel(&ray, &zp->voxel, &t, &side);

			/* Pointer to physical parameters associated with this zone */
			pp = zp->data;

			/* Do radiative transfer only if gas is present in this zone */
			if(pp->non_empty_leaf) {
				/* Do calculations on all channels at this pixel. Try to minimize the 
				 * amount of operations in this loop, since everything here is repeated 
				 * for ALL channels, and can significantly increase computation time.
				 */
				for(iv = 0; iv < glb.v.n; iv++) {
					/* Calculate velocity associated with this channel */
					dv = ((double)iv - glb.v.crpix) * glb.v.delt;

					/* Reset emission and absorption coeffs */
					j_nu = 0;
					k_nu = 0;

					if(!glb.cont && pp->has_tracer) {
						/* Calculate velocity line profile factor for this channel:
						 * This version averages over the line profile in steps
						 * of the local line width -- very time consuming! */
						vfac = SpPhys_GetVfac(&ray, t, dv, zp, 0);

						/* Calculate molecular line emission and absorption coefficients */
						SpPhys_GetMoljk((size_t)0, pp, glb.line, vfac, &j_nu, &k_nu);
					}

					/* Add continuum emission/absorption */
					j_nu += pp->cont[glb.line].j;
					k_nu += pp->cont[glb.line].k;

					/* Calculate source function and optical depth if
					 * absorption is NOT zero */
					if(fabs(k_nu) > 0.0) {
						S_nu = j_nu / k_nu / glb.I_norm;
						dtau_nu = k_nu * t * Sp_LENFAC;
					}
					else {
						S_nu = dtau_nu = 0.0;
					}

					/* Calculate intensity contributed by this step */
					//debug
					//I_nu[iv] += S_nu * (1.0 - exp(-dtau_nu)) * exp(-tau_nu[iv]);
					I_nu[iv] += (S_nu * (1.0 - exp(-dtau_nu)) + pp->cont[glb.line].I_bb) * exp(-tau_nu[iv]);

					/* Accumulate total optical depth for this channel (must be done
					 * AFTER calculation of intensity!) */
					tau_nu[iv] += dtau_nu;
				}
			}

			/* Calculate next position */
			ray = GeRay_Inc(&ray, t);

			/* Get next zone to traverse to */
			zp = Zone_GetNext(zp, side, &ray);
		}
	}

	/* Add CMB to all channels -- this is done even if the ray misses the source */
	for(iv = 0; iv < glb.v.n; iv++)
		I_nu[iv] += glb.I_cmb * exp(-tau_nu[iv]);

	return;
}


















