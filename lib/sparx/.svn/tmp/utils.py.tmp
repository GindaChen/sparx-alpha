##
## Miscellaneous utilities
## All contents in this module should be independent from the sparx
## module so circular dependencies can be avoided
##

##
## Rank of process and size of process pool
##
## DO NOT delete or rename these two attributes unless you know
## absolutely what you're doing!
##
MPI_RANK = 0
MPI_SIZE = 1

# Some necessary imports
import numpy as np
from math import log10
import os

def confirm_remove_files(files):
	"""
	Convenience function for removing a bunch of files
	interactively
	"""
	from shutil import rmtree
	from os import remove
	# ans is whether the files have been removed
	ans = True
	if len(files) > 0:
		# Print list of files to be removed
		for i in files:
			print i

		# Prompt user for decision if files are to be removed
		while True:
			ans = raw_input("Remove the above files (y/N)? ")
			if ans == '' or ans == 'N' or ans == 'n':
				ans = False
				break
			elif ans == 'y' or ans == 'Y':
				ans = True
				break
			else:
				print "Please enter 'y' or 'n' to continue"

		# If ans is True, remove all files
		if ans:
			for i in files:
				try:
					rmtree(i)
				except:
					try:
						remove(i)
					except:
						raise
	return ans

################################################################################

class Message:
	"""
	Class for handling terminal messages for the user.
	This class is tied to the MPI_RANK attribute in this module,
	so be careful when moving it to somewhere else!
	"""
	from sys import stdout, stderr
	def __init__(self, prompt, outf=stdout, errf=stderr, debug=False):
		self.prompt = prompt
		self.outf = outf
		self.errf = errf
		self.debug = debug
		return

	def __call__(self, text, stream=None):
		text += "\n"
		if stream is None:
			stream = self.outf
		if self.debug:
			pos = self._GetSrcPos(currentframe().f_back)
			self.Raw(pos+":"+self.prompt+": "+text, stream)
		else:
			self.Raw(self.prompt+": "+text, stream)
		return

	def _GetSrcPos(self, frame):
		info = getframeinfo(frame)
		return "%s:%d" % (basename(info[0]), info[1])

	def _Raw(self, text, stream):
		if MPI_RANK == 0:
			print >>stream, text,
		return

	def SetPrompt(self, prompt):
		self.prompt = str(prompt)
		return

	def Raw(self, text, stream=None):
		if stream is None:
			stream = self.outf
		self._Raw(text, stream)
		return

	def Err(self, text):
		text += "\n"
		if self.debug:
			pos = self._GetSrcPos(currentframe().f_back)
			self.Raw(pos+":"+self.prompt+" error: "+text, self.errf)
		else:
			self.Raw(self.prompt+" error: "+text, self.errf)
		return

	def HR(self, char="="):
		self.Raw(char * 80 + "\n")
		return

	def Bonk(self, text, errno=1):
		self.Err(text)
		exit(errno)
		return

##
## Instantiate message object
##
MESG = Message("sparx", debug=False)

################################################################################

def call(prog, shell=True, **kwargs):
	"""
	Convenience function for calling shell commands
	"""
	from subprocess import call
	args = " ".join(["%s=\"%s\""%(key, str(kwargs[key])) for key in kwargs])
	ret = call(prog+" "+args, shell=shell)
	if ret != 0:
		raise Exception, "'%s' failed"%prog
	return

################################################################################

def generate_linear_points(min, max, n):
	"""
	Generate n linearly spaced data points between min and max
	"""
	delta = (max - min) / n
	return np.array([min + delta * i for i in range(n)])

################################################################################

def generate_log_points(min, max, n):
	"""
	Generate n logarithmically spaced data points between min and max
	"""
	logmax = log10(max)
	logmin = log10(min)
	delta = (logmax - logmin) / n
	return np.array([10.0**(logmin + delta * i) for i in range(n)])

################################################################################

def clear_path(path):
	"""
	Make sure path is available by checking for files/directories present
	and remove accordingly
	"""
	from shutil import rmtree
	from os.path import isdir, exists
	from os import remove
	if exists(path):
		if isdir(path):
			rmtree(path)
		else:
			remove(path)
	return

################################################################################

class ParmSpace:
	def __init__(self, *parms):
		"""
		'parms' is a list of parameter names
		"""
		# Keep track of sorted list of keys. Last key is always the
		# filename
		self.parms = sorted(parms)

		# Init new parmspace: this is a dictionary of dictionaries
		self.space = {}
		self.strspace = []

		# Name of parameter table: a *tab delimited* file where
		# the first line are keys exactly the same as parms.keys()
		self.fname = "parms.tab"

		# If parms table already exists, check for consistency with
		# dictionary
		from os.path import exists, isdir
		if exists(self.fname):
			self.fo = file(self.fname, "a+")
			
			# Read first line for keys
			tab_keys = self.fo.readline().strip().split("\t")

			# Check for consistency with parms.keys()
			keys_a = ["name"] + self.parms
			keys_b = tab_keys
			if len(keys_a) == len(keys_b):
				for i in range(len(keys_a)):
					if keys_a[i] != keys_b[i]:
						raise Exception, "'%s' inconsistent with parameter space (keys are different)"%self.fname
			else:
				raise Exception, "'%s' inconsistent with parameter space (length not the same)"%self.fname

			# Load file contents into self.space
			while True:
				line = self.fo.readline()
				if not line:
					break
				else:
					# Break entry into columns
					cols = line.strip().split("\t")

					# Extract name and check whether directory exists
					name = cols.pop(0)
					if not (exists(name) and isdir(name)):
						raise Exception, "Directory '%s' does not exist"%name

					if len(cols) != len(self.parms): # Just in case
						raise Exception, "cols=%s, self.parms=%s"%(cols, self.parms)

					# strspace is for identifying repeated parmaeter combinations
					self.strspace.append("".join(cols))
					# This is the actual parameter space
					self.space[name] = {}
					for i in range(len(self.parms)):
						self.space[name][self.parms[i]] = cols[i]
		else:
			# Open new file and write header
			self.fo = file(self.fname, "w+")
			print >>self.fo, "\t".join(["name"] + self.parms)
			self.fo.flush()
			os.fsync(self.fo.fileno())
		return

	def insert(self, **parms):
		"""
		Insert parms combination into self.space and obtain unique id
		"""
		# Check whether input parms are valid
		for key in parms.keys():
			if key not in self.parms:
				raise Exception, "'%s' is not a valid parameter (%s)"%(key, ",".join(self.parms))

		# Check for missing parms
		missing_parms = []
		for key in self.parms:
			if key not in parms.keys():
				missing_parms += [key]
		if len(missing_parms) > 0:
			raise Exception, "Parameters '%s' missing"%(",".join(missing_parms))

		# Check for repeated parameter combinations
		parmstr = "".join([parms[key] for key in self.parms])
		parmstr2 = "\n".join(["%10s=%s"%(key, parms[key]) for key in self.parms])
		if parmstr not in self.strspace:
			# Get unique id
			id = "%05d"%len(self.strspace)
			self.strspace.append(parmstr)
			assert id not in self.space # Just in case

			# Insert parameters
			self.space[id] = parms

			# Make directory
			os.mkdir(id)

			# Save parameter string in dir
			fo = file(id+"/parms", "w")
			print >>fo, parmstr2
			fo.flush()
			os.fsync(fo.fileno())
			fo.close()

			# Update file
			print >>self.fo, "\t".join([id] + [self.space[id][key] for key in self.parms])
			self.fo.flush()
			os.fsync(self.fo.fileno())
		else:
			# Repeated parameter, return its id
			id = "%05d"%self.strspace.index(parmstr)

			# Check whether parms file is present
			fo = file(id+"/parms")
			fparmstr2 = fo.read()
			fo.close()
			if not parmstr2.strip() == fparmstr2.strip():
				print "parmstr2=", parmstr2
				print "fparmstr2=", fparmstr2
				raise Exception, "Prams file in directory '%s' inconsistent with parms"%id

		# Return unique id
		return id

	def save(self, fname):
		"""
		Save parameter space to aother file
		"""
		# Open file for writing
		fo = file(fname, "w")

		# Write table header
		print >>fo, "\t".join(["name"] + self.parms)

		# Loop through names
		for name in sorted(self.space.keys()):
			print >>fo, "\t".join([name] + [self.space[name][key] for key in self.parms])

		# Close file
		os.fsync(fo.fileno())
		fo.close()
		return

	def __del__(self):
		"""
		Desctructor
		"""
		# Close file
		self.fo.close()
		return



